# v3.2 关键修复: API超时 + 缓存数据隔离

**日期**: 2025-10-11
**版本**: v3.2
**状态**: ✅ 已完成代码修改，待重启测试
**修复类型**: 关键Bug修复 (Critical)

---

## 🔴 问题诊断

### 用户反馈

> "打开"管理法定货币"页面，仅手动的汇率可见，有显示"手动"标签，但没显示"手动有效至 YYYY-MM-DD，我点击"自动"，该货币的汇率没有更新，还是显示"手动"标签；其他的货币汇率都没有出现。"

**症状**:
- ✅ 页面加载快（v3.0修复成功）
- ❌ 只显示 1 条手动汇率（USD=6）
- ❌ 其他货币的自动汇率不显示
- ❌ "自动"按钮不工作
- ❌ 缺少"手动有效至"日期显示

---

## 🔍 日志分析结果

### 关键日志发现（来自 localhost-1760167673731.log）

**1. API 接收超时错误（Line 1607-1614）**
```
⛔ URL: POST http://localhost:8012/api/v1/currencies/rates-detailed
⛔ Error Type: DioExceptionType.receiveTimeout
⛔ Error Message: The request took longer than 0:01:00.000000 to receive data
```

**2. 缓存数据异常（Lines 898-913）**
```
[CurrencyProvider] No manual rates found in Hive
[CurrencyProvider] Found 1 cached entries
[CurrencyProvider] → Loaded USD: rate=6, source=manual  ⚠️ 错误！
[CurrencyProvider] _manualRates.length = 0
[CurrencyProvider] Final _exchangeRates keys: [USD]
```

**3. 手动汇率存储为空**
```
[CurrencyProvider] No manual rates found in Hive
[CurrencyProvider] _manualRates.length = 0
```

---

## 🎯 根本原因分析

### 问题 1: API 超时

**现象**: 后端 API 调用在 60 秒后超时失败

**原因**:
- 汇率 API 需要调用多个外部数据源（汇率提供商）
- 实际响应时间可能超过 60 秒
- Flutter 前端的 `receiveTimeout` 设置为 30 秒（但日志显示实际是 60 秒，可能被其他地方覆盖）

**影响**:
- 后台 API 刷新失败
- 无法获取新的汇率数据
- 用户只能看到缓存中的旧数据

### 问题 2: 缓存/手动汇率数据混淆

**现象**: 缓存中有 `source='manual'` 的数据，但 `_manualRates` 为空

**原因**:
- v3.0 的 `_saveCachedRates()` 方法保存了所有 `_exchangeRates` 中的数据
- 包括 `source='manual'` 的手动汇率
- 但手动汇率应该只存储在 `_kManualRatesKey` 中
- 导致手动汇率被错误地保存到了缓存位置

**影响**:
- 手动汇率存储位置错误
- `_loadManualRates()` 加载失败（因为数据不在正确位置）
- `_overlayManualRates()` 无法执行（因为 `_manualRates` 为空）
- 最终只显示缓存中的 1 条数据

### 数据流问题

```
启动时：
1. _loadManualRates()
   → 从 _kManualRatesKey 读取 → 空（手动汇率被错误保存到缓存）
   → _manualRates = {}

2. _loadCachedRates()
   → 从 _kCachedRatesKey 读取 → USD=6 (source=manual) ⚠️ 不应该在这里
   → _exchangeRates = {USD: 6}

3. _overlayManualRates()
   → _manualRates 是空的 → 跳过叠加
   → _exchangeRates 保持 = {USD: 6}

4. UI 显示
   → 只显示 USD=6 这 1 条汇率

5. 后台 API 刷新
   → 调用 /api/v1/currencies/rates-detailed
   → 60 秒后超时失败 ⛔
   → 没有新数据
   → 用户持续只看到 1 条汇率
```

---

## ✅ 解决方案

### 修复 1: 增加 API 超时时间

**文件**: `lib/core/config/api_config.dart`
**行**: 17-18

**修改前**:
```dart
static const Duration receiveTimeout = Duration(seconds: 30);
```

**修改后**:
```dart
// ⚡ v3.2: Increased from 30s to 180s for slow exchange rate API calls
static const Duration receiveTimeout = Duration(seconds: 180);
```

**说明**:
- 将接收超时从 30 秒增加到 180 秒（3 分钟）
- 给后端 API 足够时间完成外部汇率源调用
- 确保后台刷新能够成功完成

### 修复 2: 缓存保存排除手动汇率

**文件**: `lib/providers/currency_provider.dart`
**行**: 555-583

**修改前**:
```dart
_exchangeRates.forEach((code, rate) {
  cacheData[code] = {
    'from': rate.fromCurrency,
    'rate': rate.rate,
    'date': rate.date.toIso8601String(),
    'source': rate.source,
  };
});
```

**修改后**:
```dart
_exchangeRates.forEach((code, rate) {
  // ⚡ v3.2: Skip manual rates - they are stored in _kManualRatesKey
  if (rate.source == 'manual') {
    debugPrint('[CurrencyProvider]   ⏭️  Skipping manual rate: $code (stored separately)');
    return;
  }

  cacheData[code] = {
    'from': rate.fromCurrency,
    'rate': rate.rate,
    'date': rate.date.toIso8601String(),
    'source': rate.source,
  };
});
```

**说明**:
- 在保存缓存时，过滤掉 `source='manual'` 的汇率
- 手动汇率应该只存储在 `_kManualRatesKey` 位置
- 避免数据混淆

### 修复 3: 缓存加载过滤手动汇率

**文件**: `lib/providers/currency_provider.dart`
**行**: 277-341

**修改前**:
```dart
cached.forEach((key, value) {
  if (value is Map) {
    try {
      final code = key.toString();
      final source = value['source']?.toString() ?? 'cached';

      _exchangeRates[code] = ExchangeRate(...);
      loadedCount++;
    } catch (e) {...}
  }
});
```

**修改后**:
```dart
int skippedManual = 0;
cached.forEach((key, value) {
  if (value is Map) {
    try {
      final code = key.toString();
      final source = value['source']?.toString() ?? 'cached';

      // ⚡ v3.2: Skip manual rates from cache (should not exist, but filter for safety)
      if (source == 'manual') {
        skippedManual++;
        debugPrint('[CurrencyProvider]   ⏭️  Skipped manual rate in cache: $code (will load from _kManualRatesKey)');
        return;
      }

      _exchangeRates[code] = ExchangeRate(...);
      loadedCount++;
    } catch (e) {...}
  }
});

if (skippedManual > 0) {
  debugPrint('[CurrencyProvider] ⚠️  Skipped $skippedManual manual rates in cache (data cleanup needed)');
}
```

**说明**:
- 在加载缓存时，也过滤掉 `source='manual'` 的数据
- 虽然修复后理论上不应该有，但为了安全起见还是加上
- 如果发现有，会记录警告日志，提示需要数据清理

---

## 📊 修复效果预期

### 修复前 (v3.1) vs 修复后 (v3.2)

| 场景 | v3.1 | v3.2 |
|------|------|------|
| 页面加载速度 | <1秒 ⚡ | <1秒 ⚡ |
| API 超时 | 60秒超时 ❌ | 180秒超时（成功完成）✅ |
| 自动汇率显示 | ❌ 不显示（API超时）| ✅ 显示（API成功）|
| 手动汇率显示 | ⚠️ 仅1条（数据混淆）| ✅ 正常显示 |
| 缓存数据 | 混淆（含手动汇率）| ✅ 纯自动汇率 |
| 手动汇率存储 | ❌ 存错位置 | ✅ 正确位置 |
| 数据隔离 | ❌ 混在一起 | ✅ 完全隔离 |

---

## 🔧 技术要点

### 1. API 超时策略

**问题**:
- 汇率 API 需要调用多个外部数据源
- 30-60 秒的超时对于复杂查询不够

**解决**:
- 将 `receiveTimeout` 增加到 180 秒
- 给后端充足时间完成所有外部调用
- 前端使用 Stale-While-Revalidate 模式，用户不会感知等待

### 2. 数据存储隔离

**设计原则**:
- 手动汇率：存储在 `_kManualRatesKey`（持久化）
- 自动汇率：存储在 `_kCachedRatesKey`（临时缓存）
- 两者完全隔离，不应混淆

**实现**:
- 保存缓存时：过滤掉 `source='manual'`
- 加载缓存时：跳过 `source='manual'`
- 叠加时：手动汇率优先覆盖自动汇率

### 3. 数据流正确性

**正确的数据流**:
```
1. 启动初始化
   ├─ _loadManualRates()    → _manualRates map（从 _kManualRatesKey）
   ├─ _loadCachedRates()    → _exchangeRates map（从 _kCachedRatesKey，过滤手动）
   └─ _overlayManualRates() → 手动汇率叠加到 _exchangeRates（覆盖）

2. API 刷新完成
   ├─ 加载新的自动汇率 → _exchangeRates
   ├─ _overlayManualRates() → 手动汇率叠加
   └─ _saveCachedRates()    → 保存到缓存（排除手动汇率）

3. 手动汇率设置
   ├─ upsertManualRate()    → 更新 _manualRates
   ├─ 保存到 _kManualRatesKey
   └─ _loadExchangeRates()  → 刷新，叠加新的手动汇率
```

---

## 🧪 测试验证

### 测试场景 1: API 超时问题

**步骤**:
1. 清除浏览器缓存（清空 Hive 数据）
2. 启动 Flutter 应用
3. 登录并进入"管理法定货币"页面
4. 观察浏览器控制台日志

**预期结果** (v3.2):
- ✅ 页面立即显示（加载缓存）
- ✅ 后台 API 调用在 180 秒内完成（不超时）
- ✅ 完成后显示所有货币的汇率
- ✅ 日志显示：`Background rate refresh completed`

### 测试场景 2: 数据隔离

**步骤**:
1. 设置一个手动汇率（例如 JPY = 25.6789）
2. 等待 API 刷新完成
3. 检查浏览器 IndexedDB（Hive 数据）
4. 查看 `cached_exchange_rates` 和 `manual_rates` 两个键

**预期结果** (v3.2):
- ✅ `manual_rates` 包含 JPY = 25.6789
- ✅ `cached_exchange_rates` **不包含** JPY（或包含自动汇率，source != 'manual'）
- ✅ 日志显示：`Skipping manual rate: JPY (stored separately)`

### 测试场景 3: 手动汇率清理旧数据

**步骤**:
1. 热重载应用
2. 进入"管理法定货币"页面
3. 观察控制台日志

**预期结果** (v3.2):
- 如果缓存中有旧的手动汇率数据：
  - ✅ 日志显示：`Skipped 1 manual rates in cache (data cleanup needed)`
  - ✅ 这些数据被跳过，不会加载到 `_exchangeRates`
- 如果缓存已清理：
  - ✅ 没有跳过日志，正常加载所有自动汇率

---

## 🐛 已知问题

### 1. 缓存中的旧手动汇率数据

**问题**: 用户的旧缓存中可能有 `source='manual'` 的数据

**影响**: 会在日志中看到 "Skipped X manual rates in cache" 警告

**解决方案**:
- v3.2 的过滤逻辑会自动跳过这些数据
- 下次 API 刷新成功后，会保存新的缓存（不含手动汇率）
- 旧数据会被覆盖，问题自动解决

**用户操作**: 无需手动清理，系统会自动修复

### 2. "手动有效至"日期不显示

**状态**: 此问题不在本次修复范围内

**说明**: 这是 UI 显示问题，需要单独修复

---

## 📝 代码修改清单

### 修改 1: API 超时配置
- **文件**: `lib/core/config/api_config.dart`
- **行**: 17-18
- **类型**: 修改常量
- **说明**: `receiveTimeout` 从 30 秒增加到 180 秒

### 修改 2: 缓存保存过滤
- **文件**: `lib/providers/currency_provider.dart`
- **行**: 555-583
- **类型**: 添加过滤逻辑
- **说明**: 在 `_saveCachedRates()` 中跳过 `source='manual'` 的汇率

### 修改 3: 缓存加载过滤
- **文件**: `lib/providers/currency_provider.dart`
- **行**: 277-341
- **类型**: 添加过滤逻辑
- **说明**: 在 `_loadCachedRates()` 中跳过 `source='manual'` 的汇率，记录跳过数量

---

## ✅ 验证清单

- [x] 增加 API 超时时间（30秒 → 180秒）
- [x] 修复 `_saveCachedRates()` 排除手动汇率
- [x] 修复 `_loadCachedRates()` 过滤手动汇率
- [x] 创建 v3.2 修复报告文档
- [ ] 热重载应用测试修复效果
- [ ] 用户测试验证（等待用户反馈）

---

## 🎯 用户预期

**修复后，用户应该看到**:
1. ✅ 页面立即加载（<1秒）
2. ✅ 立即显示缓存的自动汇率
3. ✅ 手动汇率也立即显示（如果已设置）
4. ✅ 后台 API 刷新成功完成（不超时）
5. ✅ 刷新后，所有货币汇率都正确显示
6. ✅ 手动/自动切换功能正常工作

---

## 📚 相关文档

- [v3.0 即时缓存加载](./V3_INSTANT_CACHE_LOADING.md)
- [v3.1 关键修复](./V3.1_CRITICAL_BUG_FIX.md)
- [v2.0 修复报告](./MANUAL_RATE_AND_PERFORMANCE_FIX.md)

---

**报告生成时间**: 2025-10-11
**修复状态**: ✅ 代码修改完成，待热重载测试
**待用户验证**: 请按照上述测试场景验证修复效果
